From e4e9668c79dc893a29e6caf26a3bcf51acc64402 Mon Sep 17 00:00:00 2001
From: Kaiser <1244713586@qq.com>
Date: Wed, 23 Mar 2022 02:17:15 +0800
Subject: [PATCH] Add spngsave

---
 libvips/foreign/Makefile.am |   1 +
 libvips/foreign/foreign.c   |   7 +
 libvips/foreign/pngload.c   |   4 +-
 libvips/foreign/quantise.c  | 244 ++++++++--
 libvips/foreign/quantise.h  |  85 ++++
 libvips/foreign/spngload.c  |   1 -
 libvips/foreign/spngsave.c  | 925 ++++++++++++++++++++++++++++++++++++
 libvips/foreign/vipspng.c   |  16 +-
 8 files changed, 1225 insertions(+), 58 deletions(-)
 create mode 100644 libvips/foreign/quantise.h
 create mode 100644 libvips/foreign/spngsave.c

diff --git a/libvips/foreign/Makefile.am b/libvips/foreign/Makefile.am
index b118b9ff6..e58596788 100644
--- a/libvips/foreign/Makefile.am
+++ b/libvips/foreign/Makefile.am
@@ -36,6 +36,7 @@ libforeign_la_SOURCES = \
 	pdfiumload.c \
 	pforeign.h \
 	pngload.c \
+	spngsave.c \
 	pngsave.c \
 	ppmload.c \
 	ppmsave.c \
diff --git a/libvips/foreign/foreign.c b/libvips/foreign/foreign.c
index 9bf932a6d..21c254397 100644
--- a/libvips/foreign/foreign.c
+++ b/libvips/foreign/foreign.c
@@ -2817,6 +2817,10 @@ vips_foreign_operation_init( void )
 	extern GType vips_foreign_save_png_buffer_get_type( void ); 
 	extern GType vips_foreign_save_png_target_get_type( void ); 
 
+	extern GType vips_foreign_save_spng_file_get_type( void ); 
+	extern GType vips_foreign_save_spng_buffer_get_type( void ); 
+	extern GType vips_foreign_save_spng_target_get_type( void ); 
+
 	extern GType vips_foreign_load_csv_file_get_type( void ); 
 	extern GType vips_foreign_load_csv_source_get_type( void ); 
 	extern GType vips_foreign_save_csv_file_get_type( void ); 
@@ -3035,6 +3039,9 @@ vips_foreign_operation_init( void )
 	vips_foreign_load_png_file_get_type(); 
 	vips_foreign_load_png_buffer_get_type(); 
 	vips_foreign_load_png_source_get_type(); 
+	vips_foreign_save_spng_file_get_type(); 
+	vips_foreign_save_spng_buffer_get_type(); 
+	vips_foreign_save_spng_target_get_type(); 
 #endif /*HAVE_SPNG*/
 
 #ifdef HAVE_MATIO
diff --git a/libvips/foreign/pngload.c b/libvips/foreign/pngload.c
index 133414a6d..09d8a153b 100644
--- a/libvips/foreign/pngload.c
+++ b/libvips/foreign/pngload.c
@@ -52,7 +52,7 @@
 
 #include "pforeign.h"
 
-#if defined(HAVE_PNG) && !defined(HAVE_SPNG)
+#if defined(HAVE_PNG)
 
 typedef struct _VipsForeignLoadPng {
 	VipsForeignLoad parent_object;
@@ -405,7 +405,7 @@ vips_foreign_load_png_buffer_init( VipsForeignLoadPngBuffer *buffer )
 {
 }
 
-#endif /*defined(HAVE_PNG) && !defined(HAVE_SPNG)*/
+#endif /*HAVE_PNG*/
 
 /**
  * vips_pngload:
diff --git a/libvips/foreign/quantise.c b/libvips/foreign/quantise.c
index 9c5459562..c06fff2fc 100644
--- a/libvips/foreign/quantise.c
+++ b/libvips/foreign/quantise.c
@@ -1,13 +1,13 @@
-/* quantise an image with libimagequant
+/* quantise an image
  *
- * 20/6/18 
+ * 20/6/18
  * 	  - from vipspng.c
  */
 
 /*
 
     This file is part of VIPS.
-    
+
     VIPS is free software; you can redistribute it and/or modify
     it under the terms of the GNU Lesser General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
@@ -43,11 +43,164 @@
 
 #include <vips/vips.h>
 
-#ifdef HAVE_IMAGEQUANT
+#include "quantise.h"
+
+#ifdef HAVE_QUANTIZATION
 
 #include "pforeign.h"
 
-#include <libimagequant.h>
+#if defined(HAVE_IMAGEQUANT)
+
+VipsQuantiseAttr*
+vips__quantise_attr_create()
+{
+	return liq_attr_create();
+}
+
+VipsQuantiseError
+vips__quantise_set_max_colors(VipsQuantiseAttr* attr, int colors)
+{
+	return liq_set_max_colors(attr, colors);
+}
+
+VipsQuantiseError
+vips__quantise_set_quality(VipsQuantiseAttr* attr, int minimum, int maximum)
+{
+	return liq_set_quality(attr, minimum, maximum);
+}
+
+VipsQuantiseError
+vips__quantise_set_speed(VipsQuantiseAttr* attr, int speed)
+{
+	return liq_set_speed(attr, speed);
+}
+
+VipsQuantiseImage*
+vips__quantise_image_create_rgba(const VipsQuantiseAttr *attr, const void *bitmap, int width, int height, double gamma)
+{
+	return liq_image_create_rgba(attr, bitmap, width, height, gamma);
+}
+
+VipsQuantiseError
+vips__quantise_image_quantize(VipsQuantiseImage *const input_image, VipsQuantiseAttr *const options, VipsQuantiseResult **result_output)
+{
+	return liq_image_quantize(input_image, options, result_output);
+}
+
+VipsQuantiseError
+vips__quantise_set_dithering_level(VipsQuantiseResult *res, float dither_level)
+{
+	return liq_set_dithering_level(res, dither_level);
+}
+
+const VipsQuantisePalette*
+vips__quantise_get_palette(VipsQuantiseResult *result)
+{
+	return liq_get_palette(result);
+}
+
+VipsQuantiseError
+vips__quantise_write_remapped_image(VipsQuantiseResult *result, VipsQuantiseImage *input_image, void *buffer, size_t buffer_size)
+{
+	return liq_write_remapped_image(result, input_image, buffer, buffer_size);
+}
+
+void
+vips__quantise_result_destroy(VipsQuantiseResult *result)
+{
+	liq_result_destroy(result);
+}
+
+void
+vips__quantise_image_destroy(VipsQuantiseImage *img)
+{
+	liq_image_destroy(img);
+}
+
+void
+vips__quantise_attr_destroy(VipsQuantiseAttr *attr)
+{
+	liq_attr_destroy(attr);
+}
+
+#elif defined(HAVE_QUANTIZR) /*HAVE_IMAGEQUANT*/
+
+VipsQuantiseAttr*
+vips__quantise_attr_create()
+{
+	return quantizr_new_options();
+}
+
+VipsQuantiseError
+vips__quantise_set_max_colors(VipsQuantiseAttr* attr, int colors)
+{
+	return quantizr_set_max_colors(attr, colors);
+}
+
+VipsQuantiseError
+vips__quantise_set_quality(VipsQuantiseAttr* attr, int minimum, int maximum)
+{
+	// Not supported by quantizr
+	return 0;
+}
+
+VipsQuantiseError
+vips__quantise_set_speed(VipsQuantiseAttr* attr, int speed)
+{
+	// Not supported by quantizr
+	return 0;
+}
+
+VipsQuantiseImage*
+vips__quantise_image_create_rgba(const VipsQuantiseAttr *attr, const void *bitmap, int width, int height, double gamma)
+{
+	return quantizr_create_image_rgba((unsigned char*)bitmap, width, height);
+}
+
+VipsQuantiseError
+vips__quantise_image_quantize(VipsQuantiseImage *const input_image, VipsQuantiseAttr *const options, VipsQuantiseResult **result_output)
+{
+	*result_output = quantizr_quantize(input_image, options);
+	return 0;
+}
+
+VipsQuantiseError
+vips__quantise_set_dithering_level(VipsQuantiseResult *res, float dither_level)
+{
+	return quantizr_set_dithering_level(res, dither_level);
+}
+
+const VipsQuantisePalette*
+vips__quantise_get_palette(VipsQuantiseResult *result)
+{
+	return quantizr_get_palette(result);
+}
+
+VipsQuantiseError
+vips__quantise_write_remapped_image(VipsQuantiseResult *result, VipsQuantiseImage *input_image, void *buffer, size_t buffer_size)
+{
+	return quantizr_remap(result, input_image, buffer, buffer_size);
+}
+
+void
+vips__quantise_result_destroy(VipsQuantiseResult *result)
+{
+	quantizr_free_result(result);
+}
+
+void
+vips__quantise_image_destroy(VipsQuantiseImage *img)
+{
+	quantizr_free_image(img);
+}
+
+void
+vips__quantise_attr_destroy(VipsQuantiseAttr *attr)
+{
+	quantizr_free_options(attr);
+}
+
+#endif /*HAVE_QUANTIZR*/
 
 /* Track during a quantisation.
  */
@@ -60,9 +213,9 @@ typedef struct _Quantise {
 	double dither;
 	int effort;
 
-	liq_attr *attr;
-	liq_image *input_image;
-	liq_result *quantisation_result;
+	VipsQuantiseAttr *attr;
+	VipsQuantiseImage *input_image;
+	VipsQuantiseResult *quantisation_result;
 	VipsImage *t[5];
 } Quantise;
 
@@ -71,18 +224,18 @@ vips__quantise_free( Quantise *quantise )
 {
 	int i;
 
-	VIPS_FREEF( liq_result_destroy, quantise->quantisation_result );
-	VIPS_FREEF( liq_image_destroy, quantise->input_image );
-	VIPS_FREEF( liq_attr_destroy, quantise->attr );
+	VIPS_FREEF( vips__quantise_result_destroy, quantise->quantisation_result );
+	VIPS_FREEF( vips__quantise_image_destroy, quantise->input_image );
+	VIPS_FREEF( vips__quantise_attr_destroy, quantise->attr );
 
 	for( i = 0; i < VIPS_NUMBER( quantise->t ); i++ )
-		VIPS_UNREF( quantise->t[i] ); 
+		VIPS_UNREF( quantise->t[i] );
 
 	VIPS_FREE( quantise );
 }
 
 static Quantise *
-vips__quantise_new( VipsImage *in, 
+vips__quantise_new( VipsImage *in,
 	VipsImage **index_out, VipsImage **palette_out,
         int colours, int Q, double dither, int effort )
 {
@@ -98,13 +251,13 @@ vips__quantise_new( VipsImage *in,
 	quantise->dither = dither;
 	quantise->effort = effort;
 	for( i = 0; i < VIPS_NUMBER( quantise->t ); i++ )
-		quantise->t[i] = NULL; 
+		quantise->t[i] = NULL;
 
-	return( quantise ); 
+	return( quantise );
 }
 
 int
-vips__quantise_image( VipsImage *in, 
+vips__quantise_image( VipsImage *in,
 	VipsImage **index_out, VipsImage **palette_out,
 	int colours, int Q, double dither, int effort,
 	gboolean threshold_alpha )
@@ -112,31 +265,31 @@ vips__quantise_image( VipsImage *in,
 	Quantise *quantise;
 	VipsImage *index;
 	VipsImage *palette;
-	const liq_palette *lp;
+	const VipsQuantisePalette *lp;
 	gint64 i;
 	VipsPel * restrict p;
 	gboolean added_alpha;
 
-	quantise = vips__quantise_new( in, index_out, palette_out, 
+	quantise = vips__quantise_new( in, index_out, palette_out,
 		colours, Q, dither, effort );
 
-	/* Ensure input is sRGB. 
+	/* Ensure input is sRGB.
 	 */
 	if( in->Type != VIPS_INTERPRETATION_sRGB ) {
-		if( vips_colourspace( in, &quantise->t[0], 
+		if( vips_colourspace( in, &quantise->t[0],
 			VIPS_INTERPRETATION_sRGB, NULL ) ) {
-			vips__quantise_free( quantise ); 
+			vips__quantise_free( quantise );
 			return( -1 );
 		}
 		in = quantise->t[0];
 	}
 
-	/* Add alpha channel if missing. 
+	/* Add alpha channel if missing.
 	 */
 	added_alpha = FALSE;
 	if( !vips_image_hasalpha( in ) ) {
 		if( vips_bandjoin_const1( in, &quantise->t[1], 255, NULL ) ) {
-			vips__quantise_free( quantise ); 
+			vips__quantise_free( quantise );
 			return( -1 );
 		}
 		added_alpha = TRUE;
@@ -144,14 +297,14 @@ vips__quantise_image( VipsImage *in,
 	}
 
 	if( !(quantise->t[2] = vips_image_copy_memory( in )) ) {
-		vips__quantise_free( quantise ); 
+		vips__quantise_free( quantise );
 		return( -1 );
 	}
 	in = quantise->t[2];
 
 	/* Threshold alpha channel.
 	 */
-	if( threshold_alpha && 
+	if( threshold_alpha &&
 		!added_alpha ) {
 		const guint64 n_pels = VIPS_IMAGE_N_PELS( in );
 
@@ -162,42 +315,42 @@ vips__quantise_image( VipsImage *in,
 		}
 	}
 
-	quantise->attr = liq_attr_create();
-	liq_set_max_colors( quantise->attr, colours );
-	liq_set_quality( quantise->attr, 0, Q );
-	liq_set_speed( quantise->attr, 11 - effort );
+	quantise->attr = vips__quantise_attr_create();
+	vips__quantise_set_max_colors( quantise->attr, colours );
+	vips__quantise_set_quality( quantise->attr, 0, Q );
+	vips__quantise_set_speed( quantise->attr, 11 - effort );
 
-	quantise->input_image = liq_image_create_rgba( quantise->attr,
+	quantise->input_image = vips__quantise_image_create_rgba( quantise->attr,
 		VIPS_IMAGE_ADDR( in, 0, 0 ), in->Xsize, in->Ysize, 0 );
 
-	if( liq_image_quantize( quantise->input_image, quantise->attr, 
+	if( vips__quantise_image_quantize( quantise->input_image, quantise->attr,
 		&quantise->quantisation_result ) ) {
 		vips_error( "quantise", "%s", _( "quantisation failed" ) );
-		vips__quantise_free( quantise ); 
+		vips__quantise_free( quantise );
 		return( -1 );
 	}
 
-	liq_set_dithering_level( quantise->quantisation_result, dither );
+	vips__quantise_set_dithering_level( quantise->quantisation_result, dither );
 
 	index = quantise->t[3] = vips_image_new_memory();
-	vips_image_init_fields( index, 
+	vips_image_init_fields( index,
 		in->Xsize, in->Ysize, 1, VIPS_FORMAT_UCHAR,
 		VIPS_CODING_NONE, VIPS_INTERPRETATION_B_W, 1.0, 1.0 );
 
 	if( vips_image_write_prepare( index ) ) {
-		vips__quantise_free( quantise ); 
+		vips__quantise_free( quantise );
 		return( -1 );
 	}
 
-	if( liq_write_remapped_image( quantise->quantisation_result, 
+	if( vips__quantise_write_remapped_image( quantise->quantisation_result,
 		quantise->input_image,
 		VIPS_IMAGE_ADDR( index, 0, 0 ), VIPS_IMAGE_N_PELS( index ) ) ) {
 		vips_error( "quantise", "%s", _( "quantisation failed" ) );
-		vips__quantise_free( quantise ); 
+		vips__quantise_free( quantise );
 		return( -1 );
 	}
 
-	lp = liq_get_palette( quantise->quantisation_result );
+	lp = vips__quantise_get_palette( quantise->quantisation_result );
 
 	palette = quantise->t[4] = vips_image_new_memory();
 	vips_image_init_fields( palette, lp->count, 1, 4,
@@ -205,7 +358,7 @@ vips__quantise_image( VipsImage *in,
 		1.0, 1.0 );
 
 	if( vips_image_write_prepare( palette ) ) {
-		vips__quantise_free( quantise ); 
+		vips__quantise_free( quantise );
 		return( -1 );
 	}
 
@@ -224,24 +377,23 @@ vips__quantise_image( VipsImage *in,
 	*palette_out = palette;
 	g_object_ref( palette );
 
-	vips__quantise_free( quantise ); 
+	vips__quantise_free( quantise );
 
 	return( 0 );
 }
 
-#else /*!HAVE_IMAGEQUANT*/
+#else /*!HAVE_QUANTIZATION*/
 
 int
-vips__quantise_image( VipsImage *in, 
+vips__quantise_image( VipsImage *in,
 	VipsImage **index_out, VipsImage **palette_out,
 	int colours, int Q, double dither, int effort,
 	gboolean threshold_alpha )
 {
-	vips_error( "vips__quantise_image", 
-		"%s", _( "libvips not built with quantisation support" ) ); 
+	vips_error( "vips__quantise_image",
+		"%s", _( "libvips not built with quantisation support" ) );
 
 	return( -1 );
 }
 
-#endif /*HAVE_IMAGEQUANT*/
-
+#endif /*HAVE_QUANTIZATION*/
diff --git a/libvips/foreign/quantise.h b/libvips/foreign/quantise.h
new file mode 100644
index 000000000..3166dd17f
--- /dev/null
+++ b/libvips/foreign/quantise.h
@@ -0,0 +1,85 @@
+/* common defs for image quantisation
+ */
+
+/*
+
+    Copyright (C) 1991-2005 The National Gallery
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA
+
+ */
+
+/*
+
+    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
+
+ */
+
+#ifndef VIPS_QUANTISE_H
+#define VIPS_QUANTISE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /*__cplusplus*/
+
+#if defined(HAVE_IMAGEQUANT)
+#define HAVE_QUANTIZATION
+
+#include <libimagequant.h>
+
+#define VipsQuantiseAttr liq_attr
+#define VipsQuantiseImage liq_image
+#define VipsQuantiseResult liq_result
+#define VipsQuantisePalette liq_palette
+#define VipsQuantiseError liq_error
+
+#elif defined(HAVE_QUANTIZR)
+#define HAVE_QUANTIZATION
+
+#include <quantizr.h>
+
+#define VipsQuantiseAttr QuantizrOptions
+#define VipsQuantiseImage QuantizrImage
+#define VipsQuantiseResult QuantizrResult
+#define VipsQuantisePalette QuantizrPalette
+#define VipsQuantiseError QuantizrError
+#endif
+
+#ifdef HAVE_QUANTIZATION
+VipsQuantiseAttr* vips__quantise_attr_create();
+VipsQuantiseError vips__quantise_set_max_colors(VipsQuantiseAttr* attr, int colors);
+VipsQuantiseError vips__quantise_set_quality(VipsQuantiseAttr* attr, int minimum, int maximum);
+VipsQuantiseError vips__quantise_set_speed(VipsQuantiseAttr* attr, int speed);
+VipsQuantiseImage* vips__quantise_image_create_rgba(const VipsQuantiseAttr *attr, const void *bitmap, int width, int height, double gamma);
+VipsQuantiseError vips__quantise_image_quantize(VipsQuantiseImage *const input_image, VipsQuantiseAttr *const options, VipsQuantiseResult **result_output);
+VipsQuantiseError vips__quantise_set_dithering_level(VipsQuantiseResult *res, float dither_level);
+const VipsQuantisePalette* vips__quantise_get_palette(VipsQuantiseResult *result);
+VipsQuantiseError vips__quantise_write_remapped_image(VipsQuantiseResult *result, VipsQuantiseImage *input_image, void *buffer, size_t buffer_size);
+void vips__quantise_result_destroy(VipsQuantiseResult *result);
+void vips__quantise_image_destroy(VipsQuantiseImage *img);
+void vips__quantise_attr_destroy(VipsQuantiseAttr *attr);
+#endif /*HAVE_QUANTIZATION*/
+
+int vips__quantise_image( VipsImage *in,
+	VipsImage **index_out, VipsImage **palette_out,
+	int colours, int Q, double dither, int effort,
+	gboolean threshold_alpha );
+
+#ifdef __cplusplus
+}
+#endif /*__cplusplus*/
+
+#endif /*VIPS_QUANTISE_H*/
diff --git a/libvips/foreign/spngload.c b/libvips/foreign/spngload.c
index aa8db4743..3b0d2e370 100644
--- a/libvips/foreign/spngload.c
+++ b/libvips/foreign/spngload.c
@@ -76,7 +76,6 @@ typedef struct _VipsForeignLoadPng {
 	VipsInterpretation interpretation;
 	VipsBandFormat format;
 	int y_pos;
-
 } VipsForeignLoadPng;
 
 typedef VipsForeignLoadClass VipsForeignLoadPngClass;
diff --git a/libvips/foreign/spngsave.c b/libvips/foreign/spngsave.c
new file mode 100644
index 000000000..9b8cc47e2
--- /dev/null
+++ b/libvips/foreign/spngsave.c
@@ -0,0 +1,925 @@
+/* save to spng
+ *
+ * 2/12/11
+ * 	- wrap a class around the spng writer
+ * 16/7/12
+ * 	- compression should be 0-9, not 1-10
+ * 20/6/18 [felixbuenemann]
+ * 	- support spng8 palette write with palette, colours, Q, dither
+ * 24/6/20
+ * 	- add @bitdepth, deprecate @colours
+ * 11/11/21
+ * 	- use libspng for save
+ */
+
+/*
+
+    This file is part of VIPS.
+    
+    VIPS is free software; you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA
+
+ */
+
+/*
+
+    These files are distributed with VIPS - http://www.vips.ecs.soton.ac.uk
+
+ */
+
+/*
+#define DEBUG_VERBOSE
+#define DEBUG
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif /*HAVE_CONFIG_H*/
+#include <vips/intl.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <vips/vips.h>
+
+#include "pforeign.h"
+#include "quantise.h"
+
+#ifdef HAVE_SPNG
+
+#include <spng.h>
+
+typedef struct _VipsForeignSaveSpng {
+	VipsForeignSave parent_object;
+
+	int compression;
+	gboolean interlace;
+	char *profile;
+	VipsForeignPngFilter filter;
+	gboolean palette;
+	int Q;
+	double dither;
+	int bitdepth;
+	int effort;
+
+	/* Set by subclasses.
+	 */
+	VipsTarget *target;
+
+	/* Write state.
+	 */
+	spng_ctx *ctx;
+	GSList *text_chunks;
+	VipsImage *memory;
+	size_t sizeof_line;
+	VipsPel *line;
+
+	/* Deprecated.
+	 */
+	int colours;
+
+} VipsForeignSaveSpng;
+
+typedef VipsForeignSaveClass VipsForeignSaveSpngClass;
+
+G_DEFINE_ABSTRACT_TYPE( VipsForeignSaveSpng, vips_foreign_save_spng, 
+	VIPS_TYPE_FOREIGN_SAVE );
+
+static void
+vips_foreign_save_spng_dispose( GObject *gobject )
+{
+	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) gobject;
+
+	GSList *p;
+
+	if( spng->target ) 
+		vips_target_finish( spng->target );
+	VIPS_UNREF( spng->target );
+	VIPS_UNREF( spng->memory );
+	VIPS_FREEF( spng_ctx_free, spng->ctx );
+
+	for( p = spng->text_chunks; p; p = p->next ) {
+		struct spng_text *text = (struct spng_text *) p->data;
+
+		VIPS_FREE( text->text );
+		VIPS_FREE( text );
+	}
+	VIPS_FREEF( g_slist_free, spng->text_chunks );
+
+	VIPS_FREE( spng->line );
+
+	G_OBJECT_CLASS( vips_foreign_save_spng_parent_class )->
+		dispose( gobject );
+}
+
+static int
+vips_foreign_save_spng_text( VipsForeignSaveSpng *spng, 
+	const char *keyword, const char *value )
+{
+	struct spng_text *text = VIPS_NEW( NULL, struct spng_text );
+
+	vips_strncpy( text->keyword, keyword, sizeof( text->keyword ) );
+	/* FIXME ... is this right?
+	 */
+	text->type = SPNG_TEXT;
+	text->length = strlen( value );
+	text->text = g_strdup( value );
+
+	spng->text_chunks = g_slist_prepend( spng->text_chunks, text );
+	
+	return( 0 );
+}
+
+static void *
+vips_foreign_save_spng_comment( VipsImage *image, 
+	const char *field, GValue *value, void *user_data )
+{
+	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) user_data;
+
+	if( vips_isprefix( "png-comment-", field ) ) { 
+		const char *value;
+		int i;
+		char key[256];
+
+		if( vips_image_get_string( image, field, &value ) )
+			return( image );
+
+		if( strlen( field ) > 256 ||
+			sscanf( field, "png-comment-%d-%80s", &i, key ) != 2 ) {
+			vips_error( "vips2png", 
+				"%s", _( "bad png comment key" ) );
+			return( image );
+		}
+
+		vips_foreign_save_spng_text( spng, key, value );
+	}
+
+	return( NULL );
+}
+
+static int
+vips_foreign_save_spng_metadata( VipsForeignSaveSpng *spng, VipsImage *in ) 
+{
+	struct spng_iccp iccp;
+	uint32_t n_text;
+	struct spng_text *text_chunk_array;
+	int i;
+	GSList *p;
+
+	if( spng->profile ) {
+		VipsBlob *blob;
+
+		if( vips_profile_load( spng->profile, &blob, NULL ) )
+			return( -1 );
+		if( blob ) {
+			size_t length;
+			const void *data = vips_blob_get( blob, &length );
+			char *basename = g_path_get_basename( spng->profile );
+
+#ifdef DEBUG
+			printf( "write_vips: attaching %zd bytes "
+				"of ICC profile\n", length );
+#endif /*DEBUG*/
+
+			vips_strncpy( iccp.profile_name, basename, 
+				sizeof( iccp.profile_name ) );
+			iccp.profile_len = length;
+			iccp.profile = (void *) data;
+			spng_set_iccp( spng->ctx, &iccp );
+
+			vips_area_unref( (VipsArea *) blob );
+			g_free( basename );
+		}
+	}
+	else if( vips_image_get_typeof( in, VIPS_META_ICC_NAME ) ) {
+		const void *data;
+		size_t length;
+
+		if( vips_image_get_blob( in, VIPS_META_ICC_NAME,
+			&data, &length ) )
+			return( -1 );
+
+#ifdef DEBUG
+		printf( "write_vips: attaching %zd bytes "
+			"of ICC profile\n", length );
+#endif /*DEBUG*/
+
+		vips_strncpy( iccp.profile_name, "", 
+			sizeof( iccp.profile_name ) );
+		iccp.profile_len = length;
+		iccp.profile = (void *) data;
+
+		spng_set_iccp( spng->ctx, &iccp );
+	}
+
+	if( vips_image_get_typeof( in, VIPS_META_XMP_NAME ) ) {
+		const void *data;
+		size_t length;
+		char *str;
+
+		if( vips_image_get_blob( in,
+			VIPS_META_XMP_NAME, &data, &length ) )
+			return( -1 );
+
+		/* The blob form of the XMP metadata is missing the
+		 * terminating \0 bytes, we have to paste it back,
+		 * unfortunately. See pngload.
+		 */
+		str = g_malloc( length + 1 );
+		vips_strncpy( str, data, length + 1 );
+		vips_foreign_save_spng_text( spng, "XML:com.adobe.xmp", str );
+		g_free( str );
+	}
+
+	if( vips_image_map( in, vips_foreign_save_spng_comment, spng ) )
+		return( -1 );
+
+	n_text = g_slist_length( spng->text_chunks );
+	text_chunk_array = VIPS_ARRAY( NULL, n_text, struct spng_text );
+	for( i = 0, p = spng->text_chunks; p; p = p->next, i++ ) {
+		struct spng_text *text = (struct spng_text *) p->data;
+
+		text_chunk_array[i] = *text;
+	}
+#ifdef DEBUG
+	printf( "attaching %u text items\n", n_text );
+#endif /*DEBUG*/
+	spng_set_text( spng->ctx, text_chunk_array, n_text );
+	VIPS_FREE( text_chunk_array );
+
+	return( 0 );
+}
+
+/* Pack a line of 1/2/4 bit index values.
+ */
+static void
+vips_foreign_save_spng_pack( VipsForeignSaveSpng *spng, 
+	VipsPel *q, VipsPel *p, size_t n )
+{
+        int pixel_mask = 8 / spng->bitdepth - 1;
+
+        VipsPel bits;
+        size_t x;
+
+        bits = 0;
+        for( x = 0; x < n; x++ ) {
+                bits <<= spng->bitdepth;
+                bits |= p[x];
+
+                if( (x & pixel_mask) == pixel_mask )
+                        *q++ = bits;
+        }
+
+        /* Any left-over bits? Need to be left-aligned.
+         */
+        if( (x & pixel_mask) != 0 ) {
+                /* The number of bits we've collected and must
+                 * left-align and flush.
+                 */
+                int collected_bits = (x & pixel_mask) << (spng->bitdepth - 1);
+
+                *q++ = bits << (8 - collected_bits);
+        }
+}
+
+static int 
+vips_foreign_save_spng_write_fn( spng_ctx *ctx, void *user, 
+	void *data, size_t n )
+{
+	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) user;
+
+	if( vips_target_write( spng->target, data, n ) )
+		return( SPNG_IO_ERROR );
+
+	return( 0 );
+}
+
+static int
+vips_foreign_save_spng_write_block( VipsRegion *region, VipsRect *area, 
+	void *user )
+{
+	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) user;
+	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( spng );
+
+	int y;
+	int error;
+
+	/* The area to write is always a set of complete scanlines.
+	 */
+	g_assert( area->left == 0 );
+	g_assert( area->width == region->im->Xsize );
+	g_assert( area->top + area->height <= region->im->Ysize );
+
+	for( y = 0; y < area->height; y++ ) {
+		VipsPel *line;
+		size_t sizeof_line;
+
+		line = VIPS_REGION_ADDR( region, 0, area->top + y );
+		sizeof_line = VIPS_REGION_SIZEOF_LINE( region );
+
+		if( spng->bitdepth < 8 ) {
+			vips_foreign_save_spng_pack( spng,
+				spng->line, line, sizeof_line );
+			line = spng->line;
+			sizeof_line = spng->sizeof_line;
+		}
+
+		if( (error = spng_encode_row( spng->ctx, line, sizeof_line )) )
+			break;
+	}
+
+	/* You can get SPNG_EOI for the final scanline.
+	 */
+	if( error && 
+		error != SPNG_EOI ) {
+		vips_error( class->nickname, "%s", spng_strerror( error ) ); 
+		return( -1 );
+	}
+
+	return( 0 );
+}
+
+static int
+vips_foreign_save_spng_write( VipsForeignSaveSpng *spng, VipsImage *in ) 
+{
+	VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( spng );
+	VipsForeignSave *save = (VipsForeignSave *) spng;
+
+	int error;
+	struct spng_ihdr ihdr;
+	struct spng_phys phys;
+	struct spng_plte plte = { 0 };
+	struct spng_trns trns = { 0 };
+	int fmt;
+	enum spng_encode_flags encode_flags;
+
+	spng->ctx = spng_ctx_new( SPNG_CTX_ENCODER );
+
+	if( (error = spng_set_png_stream( spng->ctx, 
+		vips_foreign_save_spng_write_fn, spng )) ) {
+		vips_error( class->nickname, "%s", spng_strerror( error ) ); 
+		return( -1 );
+	}
+
+#ifdef HAVE_IMAGEQUANT
+	if( spng->palette ) {
+		VipsImage *im_index;
+		VipsImage *im_palette;
+		int palette_count;
+		int i;
+
+		if( vips__quantise_image( in, &im_index, &im_palette, 
+			1 << spng->bitdepth, 
+			spng->Q, 
+			spng->dither, 
+			spng->effort, 
+			FALSE ) )
+			return( -1 );
+
+		/* PNG is 8-bit index only.
+		 */
+		palette_count = im_palette->Xsize;
+		g_assert( palette_count <= 256 );
+
+		for( i = 0; i < palette_count; i++ ) {
+			VipsPel *p = (VipsPel *) 
+				VIPS_IMAGE_ADDR( im_palette, i, 0 );
+
+			if( p[3] == 255 ) {
+				struct spng_plte_entry *entry = 
+					&plte.entries[plte.n_entries];
+
+				entry->red = p[0];
+				entry->green = p[1];
+				entry->blue = p[2];
+				plte.n_entries += 1;
+			}
+			else {
+				trns.type3_alpha[trns.n_type3_entries] = p[3];
+				trns.n_type3_entries += 1;
+			}
+		}
+
+#ifdef DEBUG
+		printf( "attaching %d entry palette\n", plte.n_entries );
+		if( trns.n_type3_entries )
+			printf( "attaching %d transparency values\n", 
+			     trns.n_type3_entries );
+#endif /*DEBUG*/
+
+		VIPS_UNREF( im_palette );
+
+		in = spng->memory = im_index;
+	}
+#endif /*HAVE_IMAGEQUANT*/
+
+	ihdr.width = in->Xsize;
+	ihdr.height = in->Ysize;
+	ihdr.bit_depth = spng->bitdepth;
+
+	/* Low-bitdepth write needs an extra buffer for packing pixels.
+	 */
+	if( spng->bitdepth < 8 ) {
+		spng->sizeof_line = 1 + VIPS_IMAGE_SIZEOF_LINE( in ) / 
+			(8 / spng->bitdepth);
+
+		if( !(spng->line = 
+			vips_malloc( NULL, VIPS_IMAGE_SIZEOF_LINE( in ) )) )
+			return( -1 );
+	}
+
+	switch( in->Bands ) {
+	case 1:
+		if( spng->palette )
+			ihdr.color_type = SPNG_COLOR_TYPE_INDEXED; 
+		else
+			ihdr.color_type = SPNG_COLOR_TYPE_GRAYSCALE;
+		break;
+
+	case 2:
+		ihdr.color_type = SPNG_COLOR_TYPE_GRAYSCALE_ALPHA; 
+		break;
+
+	case 3:
+		ihdr.color_type = SPNG_COLOR_TYPE_TRUECOLOR;
+		break;
+
+	case 4: 
+		ihdr.color_type = SPNG_COLOR_TYPE_TRUECOLOR_ALPHA; 
+		break;
+
+	default:
+		vips_error( class->nickname, "%s", _( "bad bands" ) );
+		return( -1 );
+	}
+
+	ihdr.compression_method = 0;
+	ihdr.filter_method = 0;
+	ihdr.interlace_method = spng->interlace ? 1 : 0;
+	if( (error = spng_set_ihdr( spng->ctx, &ihdr )) ) {
+		vips_error( class->nickname, "%s", spng_strerror( error ) ); 
+		return( -1 );
+	}
+
+	spng_set_option( spng->ctx, 
+		SPNG_IMG_COMPRESSION_LEVEL, spng->compression );
+	spng_set_option( spng->ctx, 
+		SPNG_TEXT_COMPRESSION_LEVEL, spng->compression );
+	spng_set_option( spng->ctx, 
+		SPNG_FILTER_CHOICE, spng->filter );
+
+	/* Set resolution. libpng uses pixels per meter.
+	 */
+	phys.unit_specifier = 1;
+	phys.ppu_x = VIPS_RINT( in->Xres * 1000.0 );
+	phys.ppu_y = VIPS_RINT( in->Xres * 1000.0 );
+	spng_set_phys( spng->ctx, &phys );
+
+	/* Metadata.
+	 */
+	if( !save->strip &&
+		vips_foreign_save_spng_metadata( spng, in ) )
+		return( -1 );
+
+#ifdef HAVE_IMAGEQUANT
+	if( spng->palette ) {
+		spng_set_plte( spng->ctx, &plte );
+		if( trns.n_type3_entries ) 
+			spng_set_trns( spng->ctx, &trns );
+	}
+#endif /*HAVE_IMAGEQUANT*/
+
+	/* SPNG_FMT_PNG is a special value that matches the format in ihdr 
+	 */
+	fmt = SPNG_FMT_PNG;
+	encode_flags = SPNG_ENCODE_PROGRESSIVE | SPNG_ENCODE_FINALIZE;
+	if( (error = spng_encode_image( spng->ctx, 
+		NULL, -1, fmt, encode_flags )) ) {
+		vips_error( class->nickname, "%s", spng_strerror( error ) ); 
+		return( -1 );
+	}
+
+	if( spng->interlace ) {
+		/* Force the input into memory, if it's not there already.
+		 */
+		if( !spng->memory ) {
+			if( !(spng->memory = vips_image_copy_memory( in )) )
+				return( -1 );
+			in = spng->memory;
+		}
+
+		do {
+			struct spng_row_info row_info;
+			VipsPel *line;
+			size_t sizeof_line;
+
+			if( (error = 
+				spng_get_row_info( spng->ctx, &row_info )) )
+				break;
+
+			line = VIPS_IMAGE_ADDR( in, 0, row_info.row_num );
+			sizeof_line = VIPS_IMAGE_SIZEOF_LINE( in );
+
+			if( spng->bitdepth < 8 ) {
+				vips_foreign_save_spng_pack( spng,
+					spng->line, line, sizeof_line );
+				line = spng->line;
+				sizeof_line = spng->sizeof_line;
+			}
+
+			error = spng_encode_row( spng->ctx, line, sizeof_line );
+		} while( !error );
+
+		if( error != SPNG_EOI ) {
+			vips_error( class->nickname, 
+				"%s", spng_strerror( error ) ); 
+			return( -1 );
+		}
+	}
+	else {
+		if( vips_sink_disc( in, 
+			vips_foreign_save_spng_write_block, spng ) )
+			return( -1 );
+	}
+
+	vips_target_finish( spng->target );
+
+	return( 0 );
+}
+
+static int
+vips_foreign_save_spng_build( VipsObject *object )
+{
+	VipsForeignSave *save = (VipsForeignSave *) object;
+	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) object;
+
+	VipsImage *in;
+	VipsInterpretation interpretation;
+	VipsImage *x;
+
+	if( VIPS_OBJECT_CLASS( vips_foreign_save_spng_parent_class )->
+		build( object ) )
+		return( -1 );
+
+	in = save->ready;
+	g_object_ref( in );
+
+	/* Deprecated "colours" arg just sets bitdepth large enough to hold
+	 * that many colours.
+	 */
+        if( vips_object_argument_isset( object, "colours" ) ) 
+		spng->bitdepth = ceil( log2( spng->colours ) );
+
+	/* If no output bitdepth has been specified, use input Type to pick.
+	 * We only go for 16 bits for the types where we know there's a
+	 * 0-65535 range.
+	 */
+        if( !vips_object_argument_isset( object, "bitdepth" ) ) 
+		spng->bitdepth = 
+			(in->Type == VIPS_INTERPRETATION_RGB16 ||
+			 in->Type == VIPS_INTERPRETATION_GREY16) ? 16 : 8;
+
+	if( spng->bitdepth > 8 ) 
+		interpretation = in->Bands > 2 ?
+			VIPS_INTERPRETATION_RGB16 : 
+			VIPS_INTERPRETATION_GREY16;
+	else
+		interpretation = in->Bands > 2 ?
+			VIPS_INTERPRETATION_sRGB : 
+			VIPS_INTERPRETATION_B_W;
+
+	if( vips_colourspace( in, &x, interpretation, NULL ) ) {
+		g_object_unref( in );
+		return( -1 );
+	}
+	g_object_unref( in );
+	in = x;
+
+	/* colourspace will leave float srgb as float. We need to force to
+	 * uchar in these cases.
+	 */
+	if( in->Type == VIPS_INTERPRETATION_sRGB ||
+		in->Type == VIPS_INTERPRETATION_B_W ) {
+		VipsImage *x;
+
+		if( vips_cast( in, &x, VIPS_FORMAT_UCHAR, NULL ) ) {
+			g_object_unref( in );
+			return( -1 );
+		}
+		g_object_unref( in );
+		in = x;
+	}
+
+	/* If this is a RGB or RGBA image and a low bit depth has been
+	 * requested, enable palettization.
+	 */
+        if( in->Bands > 2 &&
+		spng->bitdepth < 8 )
+		spng->palette = TRUE;
+
+	if( vips_foreign_save_spng_write( spng, in ) ) {
+		g_object_unref( in );
+		return( -1 );
+	}
+
+	g_object_unref( in );
+
+	return( 0 );
+}
+
+/* Except for 8-bit inputs, we send everything else to 16. We decide on spng8
+ * vs. spng16 based on Type in_build(), see above.
+ */
+#define UC VIPS_FORMAT_UCHAR
+#define US VIPS_FORMAT_USHORT
+static int bandfmt_spng[10] = {
+/* UC  C   US  S   UI  I   F   X   D   DX */
+   UC, UC, US, US, US, US, US, US, US, US
+};
+
+static void
+vips_foreign_save_spng_class_init( VipsForeignSaveSpngClass *class )
+{
+	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
+	VipsObjectClass *object_class = (VipsObjectClass *) class;
+	VipsForeignClass *foreign_class = (VipsForeignClass *) class;
+	VipsForeignSaveClass *save_class = (VipsForeignSaveClass *) class;
+
+	gobject_class->dispose = vips_foreign_save_spng_dispose;
+	gobject_class->set_property = vips_object_set_property;
+	gobject_class->get_property = vips_object_get_property;
+
+	object_class->nickname = "spngsave_base";
+	object_class->description = _( "save spng" );
+	object_class->build = vips_foreign_save_spng_build;
+
+	foreign_class->suffs = vips__png_suffs;
+
+	save_class->saveable = VIPS_SAVEABLE_RGBA;
+	save_class->format_table = bandfmt_spng;
+
+	VIPS_ARG_INT( class, "compression", 6, 
+		_( "Compression" ), 
+		_( "Compression factor" ),
+		VIPS_ARGUMENT_OPTIONAL_INPUT,
+		G_STRUCT_OFFSET( VipsForeignSaveSpng, compression ),
+		0, 9, 6 );
+
+	VIPS_ARG_BOOL( class, "interlace", 7, 
+		_( "Interlace" ), 
+		_( "Interlace image" ),
+		VIPS_ARGUMENT_OPTIONAL_INPUT,
+		G_STRUCT_OFFSET( VipsForeignSaveSpng, interlace ),
+		FALSE );
+
+	VIPS_ARG_STRING( class, "profile", 11, 
+		_( "Profile" ), 
+		_( "ICC profile to embed" ),
+		VIPS_ARGUMENT_OPTIONAL_INPUT,
+		G_STRUCT_OFFSET( VipsForeignSaveSpng, profile ),
+		NULL );
+
+	VIPS_ARG_FLAGS( class, "filter", 12,
+		_( "Filter" ),
+		_( "libspng row filter flag(s)" ),
+		VIPS_ARGUMENT_OPTIONAL_INPUT,
+		G_STRUCT_OFFSET( VipsForeignSaveSpng, filter ),
+		VIPS_TYPE_FOREIGN_PNG_FILTER,
+		VIPS_FOREIGN_PNG_FILTER_ALL );
+
+	VIPS_ARG_BOOL( class, "palette", 13,
+		_( "Palette" ),
+		_( "Quantise to 8bpp palette" ),
+		VIPS_ARGUMENT_OPTIONAL_INPUT,
+		G_STRUCT_OFFSET( VipsForeignSaveSpng, palette ),
+		FALSE );
+
+	VIPS_ARG_INT( class, "Q", 15,
+		_( "Quality" ),
+		_( "Quantisation quality" ),
+		VIPS_ARGUMENT_OPTIONAL_INPUT,
+		G_STRUCT_OFFSET( VipsForeignSaveSpng, Q ),
+		0, 100, 100 );
+
+	VIPS_ARG_DOUBLE( class, "dither", 16,
+		_( "Dithering" ),
+		_( "Amount of dithering" ),
+		VIPS_ARGUMENT_OPTIONAL_INPUT,
+		G_STRUCT_OFFSET( VipsForeignSaveSpng, dither ),
+		0.0, 1.0, 1.0 );
+
+	VIPS_ARG_INT( class, "bitdepth", 17,
+		_( "Bit depth" ),
+		_( "Write as a 1, 2, 4, 8 or 16 bit image" ),
+		VIPS_ARGUMENT_OPTIONAL_INPUT,
+		G_STRUCT_OFFSET( VipsForeignSaveSpng, bitdepth ),
+		0, 16, 0 );
+
+	VIPS_ARG_INT( class, "effort", 18,
+		_( "Effort" ),
+		_( "Quantisation CPU effort" ),
+		VIPS_ARGUMENT_OPTIONAL_INPUT,
+		G_STRUCT_OFFSET( VipsForeignSaveSpng, effort ),
+		1, 10, 7 );
+
+	VIPS_ARG_INT( class, "colours", 14,
+		_( "Colours" ),
+		_( "Max number of palette colours" ),
+		VIPS_ARGUMENT_OPTIONAL_INPUT | VIPS_ARGUMENT_DEPRECATED,
+		G_STRUCT_OFFSET( VipsForeignSaveSpng, colours ),
+		2, 256, 256 );
+
+}
+
+static void
+vips_foreign_save_spng_init( VipsForeignSaveSpng *spng )
+{
+	spng->compression = 6;
+	spng->filter = VIPS_FOREIGN_PNG_FILTER_ALL;
+	spng->Q = 100;
+	spng->dither = 1.0;
+	spng->effort = 7;
+}
+
+typedef struct _VipsForeignSaveSpngTarget {
+	VipsForeignSaveSpng parent_object;
+
+	VipsTarget *target;
+} VipsForeignSaveSpngTarget;
+
+typedef VipsForeignSaveSpngClass VipsForeignSaveSpngTargetClass;
+
+G_DEFINE_TYPE( VipsForeignSaveSpngTarget, vips_foreign_save_spng_target, 
+	vips_foreign_save_spng_get_type() );
+
+static int
+vips_foreign_save_spng_target_build( VipsObject *object )
+{
+	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) object;
+	VipsForeignSaveSpngTarget *target = 
+		(VipsForeignSaveSpngTarget *) object;
+
+	spng->target = target->target;
+	g_object_ref( spng->target );
+
+	if( VIPS_OBJECT_CLASS( vips_foreign_save_spng_target_parent_class )->
+		build( object ) )
+		return( -1 );
+
+	return( 0 );
+}
+
+static void
+vips_foreign_save_spng_target_class_init( VipsForeignSaveSpngTargetClass *class )
+{
+	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
+	VipsObjectClass *object_class = (VipsObjectClass *) class;
+
+	gobject_class->set_property = vips_object_set_property;
+	gobject_class->get_property = vips_object_get_property;
+
+	object_class->nickname = "pngsave_target";
+	object_class->description = _( "save image to target as PNG" );
+	object_class->build = vips_foreign_save_spng_target_build;
+
+	VIPS_ARG_OBJECT( class, "target", 1,
+		_( "Target" ),
+		_( "Target to save to" ),
+		VIPS_ARGUMENT_REQUIRED_INPUT, 
+		G_STRUCT_OFFSET( VipsForeignSaveSpngTarget, target ),
+		VIPS_TYPE_TARGET );
+
+}
+
+static void
+vips_foreign_save_spng_target_init( VipsForeignSaveSpngTarget *target )
+{
+}
+
+typedef struct _VipsForeignSaveSpngFile {
+	VipsForeignSaveSpng parent_object;
+
+	char *filename; 
+} VipsForeignSaveSpngFile;
+
+typedef VipsForeignSaveSpngClass VipsForeignSaveSpngFileClass;
+
+G_DEFINE_TYPE( VipsForeignSaveSpngFile, vips_foreign_save_spng_file, 
+	vips_foreign_save_spng_get_type() );
+
+static int
+vips_foreign_save_spng_file_build( VipsObject *object )
+{
+	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) object;
+	VipsForeignSaveSpngFile *file = (VipsForeignSaveSpngFile *) object;
+
+	if( !(spng->target = vips_target_new_to_file( file->filename )) )
+		return( -1 );
+
+	if( VIPS_OBJECT_CLASS( vips_foreign_save_spng_file_parent_class )->
+		build( object ) )
+		return( -1 );
+
+	return( 0 );
+}
+
+static void
+vips_foreign_save_spng_file_class_init( VipsForeignSaveSpngFileClass *class )
+{
+	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
+	VipsObjectClass *object_class = (VipsObjectClass *) class;
+
+	gobject_class->set_property = vips_object_set_property;
+	gobject_class->get_property = vips_object_get_property;
+
+	object_class->nickname = "pngsave";
+	object_class->description = _( "save image to file as PNG" );
+	object_class->build = vips_foreign_save_spng_file_build;
+
+	VIPS_ARG_STRING( class, "filename", 1, 
+		_( "Filename" ),
+		_( "Filename to save to" ),
+		VIPS_ARGUMENT_REQUIRED_INPUT, 
+		G_STRUCT_OFFSET( VipsForeignSaveSpngFile, filename ),
+		NULL );
+}
+
+static void
+vips_foreign_save_spng_file_init( VipsForeignSaveSpngFile *file )
+{
+}
+
+typedef struct _VipsForeignSaveSpngBuffer {
+	VipsForeignSaveSpng parent_object;
+
+	VipsArea *buf;
+} VipsForeignSaveSpngBuffer;
+
+typedef VipsForeignSaveSpngClass VipsForeignSaveSpngBufferClass;
+
+G_DEFINE_TYPE( VipsForeignSaveSpngBuffer, vips_foreign_save_spng_buffer, 
+	vips_foreign_save_spng_get_type() );
+
+static int
+vips_foreign_save_spng_buffer_build( VipsObject *object )
+{
+	VipsForeignSaveSpng *spng = (VipsForeignSaveSpng *) object;
+	VipsForeignSaveSpngBuffer *buffer = 
+		(VipsForeignSaveSpngBuffer *) object;
+
+	VipsBlob *blob;
+
+	if( !(spng->target = vips_target_new_to_memory()) )
+		return( -1 );
+
+	if( VIPS_OBJECT_CLASS( vips_foreign_save_spng_buffer_parent_class )->
+		build( object ) )
+		return( -1 );
+
+	g_object_get( spng->target, "blob", &blob, NULL );
+	g_object_set( buffer, "buffer", blob, NULL );
+	vips_area_unref( VIPS_AREA( blob ) );
+
+	return( 0 );
+}
+
+static void
+vips_foreign_save_spng_buffer_class_init( VipsForeignSaveSpngBufferClass *class )
+{
+	GObjectClass *gobject_class = G_OBJECT_CLASS( class );
+	VipsObjectClass *object_class = (VipsObjectClass *) class;
+
+	gobject_class->set_property = vips_object_set_property;
+	gobject_class->get_property = vips_object_get_property;
+
+	object_class->nickname = "pngsave_buffer";
+	object_class->description = _( "save image to buffer as PNG" );
+	object_class->build = vips_foreign_save_spng_buffer_build;
+
+	VIPS_ARG_BOXED( class, "buffer", 1, 
+		_( "Buffer" ),
+		_( "Buffer to save to" ),
+		VIPS_ARGUMENT_REQUIRED_OUTPUT, 
+		G_STRUCT_OFFSET( VipsForeignSaveSpngBuffer, buf ),
+		VIPS_TYPE_BLOB );
+}
+
+static void
+vips_foreign_save_spng_buffer_init( VipsForeignSaveSpngBuffer *buffer )
+{
+}
+
+#endif /*HAVE_SPNG*/
diff --git a/libvips/foreign/vipspng.c b/libvips/foreign/vipspng.c
index 2c2999d84..50d4d0cda 100644
--- a/libvips/foreign/vipspng.c
+++ b/libvips/foreign/vipspng.c
@@ -124,8 +124,6 @@
 #endif /*HAVE_CONFIG_H*/
 #include <vips/intl.h>
 
-#ifdef HAVE_PNG
-
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -136,6 +134,12 @@
 
 #include "pforeign.h"
 
+/* Shared with spng load/save.
+ */
+const char *vips__png_suffs[] = { ".png", NULL };
+
+#ifdef HAVE_PNG
+
 #include <png.h>
 
 #if PNG_LIBPNG_VER < 10003
@@ -167,8 +171,6 @@ user_warning_function( png_structp png_ptr, png_const_charp warning_msg )
 	g_warning( "%s", warning_msg );
 }
 
-#ifndef HAVE_SPNG
-
 #define INPUT_BUFFER_SIZE (4096)
 
 /* What we track during a PNG read.
@@ -638,7 +640,7 @@ png2vips_header( Read *read, VipsImage *out )
 				array, n );
 	}
 }
-#endif
+#endif /*PNG_bKGD_SUPPORTED*/
 
 	return( 0 );
 }
@@ -848,10 +850,6 @@ vips__png_isinterlaced_source( VipsSource *source )
 	return( interlace_type != PNG_INTERLACE_NONE );
 }
 
-#endif /*!defined(HAVE_SPNG)*/
-
-const char *vips__png_suffs[] = { ".png", NULL };
-
 /* What we track during a PNG write.
  */
 typedef struct {
-- 
2.32.0

