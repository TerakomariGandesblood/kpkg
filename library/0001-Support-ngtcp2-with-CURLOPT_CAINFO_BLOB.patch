From aad3eda0b1507b7fb2463a25c44dcd3fbbe44f0f Mon Sep 17 00:00:00 2001
From: Kaiser <kaiserlancelot123@gmail.com>
Date: Thu, 7 Apr 2022 14:09:23 +0800
Subject: [PATCH] Support ngtcp2 with CURLOPT_CAINFO_BLOB

---
 lib/vquic/ngtcp2.c | 85 +++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 80 insertions(+), 5 deletions(-)

diff --git a/lib/vquic/ngtcp2.c b/lib/vquic/ngtcp2.c
index d333aa8..cd24797 100644
--- a/lib/vquic/ngtcp2.c
+++ b/lib/vquic/ngtcp2.c
@@ -271,6 +271,67 @@ static SSL_QUIC_METHOD quic_method = {quic_set_read_secret,
                                       quic_add_handshake_data,
                                       quic_flush_flight, quic_send_alert};
 
+static CURLcode load_cacert_from_memory(SSL_CTX *ctx,
+                        const struct curl_blob *ca_info_blob)
+{
+  /* these need to be freed at the end */
+  BIO *cbio = NULL;
+  STACK_OF(X509_INFO) *inf = NULL;
+
+  /* everything else is just a reference */
+  int i, count = 0;
+  X509_STORE *cts = NULL;
+  X509_INFO *itmp = NULL;
+
+  if(ca_info_blob->len > (size_t)INT_MAX)
+    return CURLE_SSL_CACERT_BADFILE;
+
+  cts = SSL_CTX_get_cert_store(ctx);
+  if(!cts)
+    return CURLE_OUT_OF_MEMORY;
+
+  cbio = BIO_new_mem_buf(ca_info_blob->data, (int)ca_info_blob->len);
+  if(!cbio)
+    return CURLE_OUT_OF_MEMORY;
+
+  inf = PEM_X509_INFO_read_bio(cbio, NULL, NULL, NULL);
+  if(!inf) {
+    BIO_free(cbio);
+    return CURLE_SSL_CACERT_BADFILE;
+  }
+
+  /* add each entry from PEM file to x509_store */
+  for(i = 0; i < (int)sk_X509_INFO_num(inf); ++i) {
+    itmp = sk_X509_INFO_value(inf, i);
+    if(itmp->x509) {
+      if(X509_STORE_add_cert(cts, itmp->x509)) {
+        ++count;
+      }
+      else {
+        /* set count to 0 to return an error */
+        count = 0;
+        break;
+      }
+    }
+    if(itmp->crl) {
+      if(X509_STORE_add_crl(cts, itmp->crl)) {
+        ++count;
+      }
+      else {
+        /* set count to 0 to return an error */
+        count = 0;
+        break;
+      }
+    }
+  }
+
+  sk_X509_INFO_pop_free(inf, X509_INFO_free);
+  BIO_free(cbio);
+
+  /* if we didn't end up importing anything, treat that as an error */
+  return (count > 0 ? CURLE_OK : CURLE_SSL_CACERT_BADFILE);
+}
+
 static SSL_CTX *quic_ssl_ctx(struct Curl_easy *data)
 {
   SSL_CTX *ssl_ctx = SSL_CTX_new(TLS_method());
@@ -278,8 +339,6 @@ static SSL_CTX *quic_ssl_ctx(struct Curl_easy *data)
   SSL_CTX_set_min_proto_version(ssl_ctx, TLS1_3_VERSION);
   SSL_CTX_set_max_proto_version(ssl_ctx, TLS1_3_VERSION);
 
-  SSL_CTX_set_default_verify_paths(ssl_ctx);
-
   if(SSL_CTX_set1_curves_list(ssl_ctx, QUIC_GROUPS) != 1) {
     failf(data, "SSL_CTX_set1_groups_list failed");
     return NULL;
@@ -295,10 +354,22 @@ static SSL_CTX *quic_ssl_ctx(struct Curl_easy *data)
 
   {
     struct connectdata *conn = data->conn;
-    const char * const ssl_cafile = conn->ssl_config.CAfile;
-    const char * const ssl_capath = conn->ssl_config.CApath;
+    const struct curl_blob * ca_info_blob = conn->ssl_config.ca_info_blob;
+    const char * const ssl_cafile = (ca_info_blob ? NULL : conn->ssl_config.CAfile);
+    const char * const ssl_capath = (ca_info_blob ? NULL : conn->ssl_config.CApath);
+
+    if(ca_info_blob) {
+      CURLcode result = load_cacert_from_memory(ssl_ctx, ca_info_blob);
+      if(result) {
+        if(result == CURLE_OUT_OF_MEMORY || conn->ssl_config.verifypeer) {
+          failf(data, "error importing CA certificate blob");
+          return NULL;
+        }
+        infof(data, "error importing CA certificate blob, continuing anyway");
+      }
+    }
 
-    if(conn->ssl_config.verifypeer) {
+    if(conn->ssl_config.verifypeer && (ssl_cafile || ssl_capath)) {
       SSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);
       /* tell OpenSSL where to find CA certificates that are used to verify
          the server's certificate. */
@@ -313,6 +384,10 @@ static SSL_CTX *quic_ssl_ctx(struct Curl_easy *data)
       infof(data, " CAfile: %s", ssl_cafile ? ssl_cafile : "none");
       infof(data, " CApath: %s", ssl_capath ? ssl_capath : "none");
     }
+
+    if(conn->ssl_config.verifypeer && !ca_info_blob && !ssl_cafile && !ssl_capath) {
+      SSL_CTX_set_default_verify_paths(ssl_ctx);
+    }
   }
   return ssl_ctx;
 }
-- 
2.32.0

